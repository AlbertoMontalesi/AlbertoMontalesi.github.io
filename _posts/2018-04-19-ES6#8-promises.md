---
title: "JavaScript ES6 for Beginners #8: Promises"
categories:
  - ES6
tags:
  - programming
  - guide
---

![ES6-card-8](https://albertomontalesi.github.io/assets/images/ES6/ES6-card-8.jpg)

## What is a Promise?

From MDN:
>  A Promise is an object representing the eventual completion or failure of an asynchronous operation.

JavaScript works almost entirely asynchronously which means that when we are retrieving something from an API, for example, our code won't stop executing. Look at this example to understand what is going to happen:

```js
const data = fetch('your-api-url-goes-here');
console.log('Finished');
console.log(data);
```
The code won't stop once it hits the fetch, therefore our next console.log will be executed before we actually get some value in return, meaning that the **console.log(data)** will be empty.

To avoid this we would use a **callbacks** or **promises**.

### Callback hell

You may have heard of something called **callback hell** which looks roughly like this:

``` js
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

```

We try to write our code in a way where executions happens visually from top to bottom, causing excessive nesting on functions and result in what you can see above.

To improve your callbacks you can read this [article](http://callbackhell.com/).

Here we will focus on how to write Promises.


## Creat your own promise

```js
const myPromise = new Promise((resolve, reject) => {

});
```

This is how you create your own promise, **resolve** and **reject** will be called once the promise is finished.

We can immediately return it to see what we would get:

```js
const myPromise = new Promise((resolve, reject) => {
  resolve("The value we get from the promise");
});

myPromise.then(
  data => {
    console.log(data);
  });
// The value we get from the promise
```
We immediately resolved our promise and see the resuult in the console.

We can combine a **setTimeout()** to wait a certain amount of time before resolving.

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
      resolve("The value we get from the promise");
    }, 2000);
});

myPromise.then(
  data => {
    console.log(data);
  });
// after 2 seconds we will get:
// The value we get from the promise
```

These two examples are very simple but **promises** are very useful when dealing big requests of data.
We don't want all our code to stop while we wait for the data to come back, we want it to continue and that is where promises are useful.

In the example above we kept it simple and only resolved our promise but in reality you will also encounter errors so let's see how to deal with them:

``` js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
      reject(Error("this is our error"));
    }, 2000);
});

myPromise
  .then(data => {
    console.log(data);
  })
  .catch(err => {
    console.error(err);
  })
  // Error: this is our error
  // Stack trace:
  // myPromise</<@debugger eval code:3:14
```

We use **.then()** to grab the value when the promise resolves and **.catch()** when the promise rejects.

If you see our error log you can see that it tells us where the error occured, that is because we wrote **reject(Error("this is our error"));** and not simply **reject("this is our error");**.

### Chaining promises

We can chaing promises one after the other, using what was returned from the previous one as the base for the subsequent one, whether the promise resolved or got rejected.

``` js
const myPromise = new Promise((resolve, reject) => {
  resolve();
});

myPromise
  .then(data => {
    // take the data returned and call a function on it
    return doSomething(data);
  })
  .then(data => {
    // log the data that we got from the previous promise
    console.log(data);
  })
  .catch(err => {
    console.error(err);
  })
```
We called a function (it can do whatever you want, in this case it does nothing) and we passed then value down to the next step where we logged it.

You can chain as many promises as you want and the code will still be more readable and shorter than what we have seen above in the **callback hell**.

We are not limited to chaining in case of success, we can also chain when we get a *reject*.

```js
const myPromise = new Promise((resolve, reject) => {
  resolve();
});

myPromise
  .then(data => {
    // take the data returned and call a function on it
    throw new Error("ooops");

    console.log("first value");
  })
  .catch(() => {
    console.log("catch an error");
  })
  .then(data => {
  console.log("second value");
  });
  // catch an error
  // second value
```
We did not get "first value" because we threw an error therefore we only got the first .catch() and the last .then().




### Promise.resolve() & Promise.reject()


### Promise.all() & Promise.race()



---
&nbsp;

This was the seventh part of my ES6 for beginners course, check out the rest of them [here](https://albertomontalesi.github.io/courses/es6).

You can also read this articles on medium, on my [profile](https://medium.com/@labby92).

Thank you for reading.